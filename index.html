<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LADA 2107 Drift - FBX Model</title>
    <style>
        /* Base styles */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: white;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
        }
        
        /* UI container */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 1px 1px 2px #000;
        }
        h1 { 
            margin: 0; 
            font-size: 24px; 
            color: #ff9900; 
        }
        p { 
            margin: 5px 0; 
            color: #ccc; 
            font-size: 16px; 
        }
        .key { 
            color: #00ffff; 
            font-weight: bold; 
        }
        
        /* Drift Angle Indicator */
        #drift-angle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px; 
            height: 100px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.4);
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #ffcc00;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
            pointer-events: none;
        }
        #drift-angle span {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ff9900;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
</head>
<body>

<div id="loading">LOADING CAR MODEL...</div>

<div id="ui">
    <h1>LADA 2107 DRIFT üõ†Ô∏è</h1>
    <p><span class="key">WASD</span> to Drive | <span class="key">SPACE</span> to Handbrake</p>
    <p id="speed">0 KM/H</p>
    <p id="slide-val">Slide: 0</p>
</div>

<div id="drift-angle">
    <span id="angle-value">0¬∞</span>
    <span>DRIFT ANGLE</span>
</div>

<script>
    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer;
    let carGroup, carBody; 
    let wheels = [];
    let skidmarks = [];
    let smokeParticles = [];
    const maxSmokeParticles = 300;
    
    // Physics State
    let pos = { x: 0, z: 0 };
    let vel = { x: 0, z: 0 }; 
    let angle = 0; 
    
    // Configuration
    const CONFIG = {
        accel: 0.6,
        reverse: 0.025,
        turnSpeed: 0.05,
        drag: 0.97,
        grip: 0.15,
        drift: 0.85, 
        tilt: 0.015 
    };

    const keys = { w: false, a: false, s: false, d: false, space: false };

    // --- SMOKE TEXTURE ---
    function createSmokeTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0, 
            canvas.width / 2, canvas.height / 2, canvas.width / 2
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return new THREE.CanvasTexture(canvas);
    }

    const smokeMaterial = new THREE.SpriteMaterial({ 
        color: 0xaaaaaa, 
        transparent: true, 
        opacity: 0.8, 
        map: createSmokeTexture(), 
        blending: THREE.AdditiveBlending,
        depthWrite: false 
    });

    function init() {
        // 1. SCENE
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101015);
        scene.fog = new THREE.FogExp2(0x101015, 0.001); 

        // 2. CAMERA
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 70, -100); 

        // 3. RENDERER
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        
        // 4. LIGHTING
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 200, -100);
        dirLight.castShadow = true;
        // Enhance shadow resolution for the detailed model
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        const d = 500;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        // 5. ENVIRONMENT
        const planeGeo = new THREE.PlaneGeometry(10000, 10000);
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x151515, 
            roughness: 0.9, 
            metalness: 0.1 
        });
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const grid = new THREE.GridHelper(10000, 200, 0x333333, 0x1a1a1a);
        grid.position.y = 0.1;
        scene.add(grid);

        // 6. BUILD CAR
        createLada();

        // 7. LISTENERS
        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', (e) => updateKey(e, true));
        window.addEventListener('keyup', (e) => updateKey(e, false));

        // 8. START
        animate();
    }

    function createLada() {
        carGroup = new THREE.Group();
        scene.add(carGroup);

        // --- CAR BODY GROUP (Handles Tilt) ---
        carBody = new THREE.Group();
        carGroup.add(carBody);

        // --- LOAD FBX MODEL ---
        const loader = new THREE.FBXLoader();
        const modelUrl = 'https://github.com/mooodev/tools/raw/refs/heads/main/images/Lada.fbx';

        loader.load(modelUrl, (object) => {
            // Scale and Position Adjustment for the specific Lada model
            // The model needs to fit our physics world units
            const s = 0.32; 
            object.scale.set(s, s, s);
            object.rotation.y = Math.PI; // Rotate to face forward
            object.position.y = -5.5; // Lower body to align with wheels
            object.position.z = 2;    // Center body on wheelbase

            object.traverse(function (child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Enhance material look if possible
                    if(child.material) {
                        child.material.metalness = 0.6;
                        child.material.roughness = 0.3;
                    }
                }
            });

            carBody.add(object);
            
            // Hide Loading UI
            document.getElementById('loading').style.display = 'none';
            
            // Add Spotlights (Headlights) attached to the loaded body
            createHeadlights();

        }, (xhr) => {
            // Progress (optional)
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        }, (error) => {
            console.error('An error happened loading the model', error);
            document.getElementById('loading').innerText = "ERROR LOADING MODEL";
        });


        // --- PHYSICS WHEELS (Invisible or Dark placeholders) ---
        // We keep these for the rotation logic, but make them black/subtle
        const wheelGeo = new THREE.CylinderGeometry(3.2, 3.2, 2.2, 32);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
        const wPos = [
            { x: -10.5, z: 14 }, { x: 10.5, z: 14 },
            { x: -10.5, z: -14 }, { x: 10.5, z: -14 }
        ];

        wPos.forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(p.x, 3.2, p.z);
            w.castShadow = true;
            carGroup.add(w);
            wheels.push(w);
        });
    }

    function createHeadlights() {
        function createSpot(x) {
            const spot = new THREE.SpotLight(0xffffee, 10);
            spot.position.set(x, 6, 22);
            spot.angle = 0.5;
            spot.penumbra = 0.5; 
            spot.decay = 2;
            spot.distance = 300;
            spot.castShadow = true;
            spot.shadow.bias = -0.0001;

            const target = new THREE.Object3D();
            target.position.set(x, 2, 50); 
            
            spot.target = target;
            carBody.add(spot);
            carBody.add(target);

            // Add glow sprite
            const spriteMat = new THREE.SpriteMaterial({ 
                color: 0xffffee, 
                transparent: true, opacity: 0.5, 
                blending: THREE.AdditiveBlending 
            });
            const glow = new THREE.Sprite(spriteMat);
            glow.position.set(x, 6, 24);
            glow.scale.set(6, 6, 1);
            carBody.add(glow);
        }
        createSpot(-7);
        createSpot(7);
    }

    function updateKey(e, state) {
        const k = e.key.toLowerCase();
        if (k === 'w' || k === 'arrowup') keys.w = state;
        if (k === 's' || k === 'arrowdown') keys.s = state;
        if (k === 'a' || k === 'arrowleft') keys.a = state;
        if (k === 'd' || k === 'arrowright') keys.d = state;
        if (k === ' ') keys.space = state;
    }

    // --- SKIDMARKS & PARTICLES ---
    function addSkidmark(x, z, rot, slide) {
        if (Math.abs(slide) < 0.5) return; 
        const geo = new THREE.PlaneGeometry(12, 3); 
        const opacity = Math.min(Math.abs(slide)/30, 0.4); 
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x0a0a0a, opacity: opacity, transparent: true, side: THREE.DoubleSide, depthWrite: false 
        });
        const m = new THREE.Mesh(geo, mat);
        m.rotation.x = -Math.PI / 2;
        m.rotation.z = rot;
        m.position.set(x, 0.05, z); 
        scene.add(m);
        skidmarks.push({ mesh: m, life: 1000 }); 
    }

    function updateSkidmarks() {
        for (let i = skidmarks.length - 1; i >= 0; i--) {
            let s = skidmarks[i];
            s.life--;
            s.mesh.material.opacity *= 0.999; 
            if (s.life <= 0) {
                scene.remove(s.mesh);
                skidmarks.splice(i, 1);
            }
        }
    }

    function addSmokeParticle(x, z, rot, slideVal) {
        if (Math.abs(slideVal) < 0.5) return; 
        const slideFactor = Math.abs(slideVal) / 5; 
        const wheelOffsetZ = 14; const wheelOffsetX = 10.5;
        const rearL_x = x + Math.sin(rot) * -wheelOffsetZ + Math.cos(rot) * -wheelOffsetX;
        const rearL_z = z + Math.cos(rot) * -wheelOffsetZ - Math.sin(rot) * -wheelOffsetX;
        const rearR_x = x + Math.sin(rot) * -wheelOffsetZ + Math.cos(rot) * wheelOffsetX;
        const rearR_z = z + Math.cos(rot) * -wheelOffsetZ - Math.sin(rot) * wheelOffsetX;

        [{ x: rearL_x, z: rearL_z }, { x: rearR_x, z: rearR_z }].forEach(p => {
            if (smokeParticles.length >= maxSmokeParticles) return;
            if (Math.random() > 0.4) return; 
            const size = Math.random() * 5 + 3 + slideFactor; 
            const sprite = new THREE.Sprite(smokeMaterial.clone());
            sprite.position.set(p.x + Math.random() * 1.5 - 0.75, 1, p.z + Math.random() * 1.5 - 0.75);
            sprite.scale.set(size, size, size);
            sprite.material.opacity = 0.4 + Math.random() * 0.3; 
            scene.add(sprite);
            smokeParticles.push({
                mesh: sprite, life: 60 + Math.random() * 60, startLife: 60,
                vx: (Math.random() * 0.2 - 0.1) * slideFactor, vz: (Math.random() * 0.2 - 0.1) * slideFactor
            });
        });
    }

    function updateSmokeParticles() {
        for (let i = smokeParticles.length - 1; i >= 0; i--) {
            let p = smokeParticles[i];
            p.mesh.position.y += 0.05; 
            p.mesh.position.x += p.vx;
            p.mesh.position.z += p.vz;
            p.life--;
            const lifeRatio = p.life / p.startLife;
            p.mesh.material.opacity = Math.max(0, lifeRatio) * 0.6; 
            p.mesh.scale.multiplyScalar(1.02); 
            if (p.life <= 0) {
                scene.remove(p.mesh);
                smokeParticles.splice(i, 1);
            }
        }
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // Physics
        const sin = Math.sin(angle);
        const cos = Math.cos(angle);
        let fwdVel = (vel.x * sin) + (vel.z * cos);
        let sideVel = (vel.x * cos) - (vel.z * sin);

        if (keys.w) fwdVel += CONFIG.accel;
        if (keys.s) fwdVel -= CONFIG.reverse;

        if (Math.abs(fwdVel) > 0.1) {
            const dir = fwdVel > 0 ? 1 : -1; 
            if (keys.a) angle += CONFIG.turnSpeed * dir;
            if (keys.d) angle -= CONFIG.turnSpeed * dir;
        }

        fwdVel *= CONFIG.drag;
        const sideFriction = keys.space ? CONFIG.drift : CONFIG.grip;
        sideVel *= sideFriction;

        vel.x = (sin * fwdVel) + (cos * sideVel);
        vel.z = (cos * fwdVel) - (sin * sideVel);

        pos.x += vel.x;
        pos.z += vel.z;

        // Update Visuals
        carGroup.position.set(pos.x, 0, pos.z);
        carGroup.rotation.y = angle;

        wheels.forEach(w => w.rotation.x += fwdVel * 0.1);

        carBody.rotation.z = -sideVel * CONFIG.tilt; 
        carBody.rotation.x = -fwdVel * 0.005; 

        // Effects
        if ((Math.abs(sideVel) > 0.5 || keys.space) && Math.abs(fwdVel) > 0.5) { 
            const wheelOffset = 10.5;
            addSkidmark(pos.x - Math.sin(angle + Math.PI/2) * wheelOffset, pos.z - Math.cos(angle + Math.PI/2) * wheelOffset, angle, sideVel);
            addSkidmark(pos.x + Math.sin(angle + Math.PI/2) * wheelOffset, pos.z + Math.cos(angle + Math.PI/2) * wheelOffset, angle, sideVel);
            addSmokeParticle(pos.x, pos.z, angle, sideVel);
        }
        updateSkidmarks();
        updateSmokeParticles();

        // Camera
        const camDist = 80;
        const camHeight = 30;
        const targetX = pos.x - Math.sin(angle) * camDist;
        const targetZ = pos.z - Math.cos(angle) * camDist;
        const smoothFactor = 0.08; 
        camera.position.x += (targetX - camera.position.x) * smoothFactor;
        camera.position.z += (targetZ - camera.position.z) * smoothFactor;
        camera.position.y += (camHeight - camera.position.y) * smoothFactor;
        camera.lookAt(pos.x, 0, pos.z);

        // UI
        const currentSpeed = Math.floor(Math.abs(fwdVel * 5));
        const driftAngle = Math.floor(Math.abs(sideVel) * 20); 
        
        document.getElementById('speed').innerText = `${currentSpeed} KM/H`;
        document.getElementById('slide-val').innerText = `Slide: ${driftAngle.toFixed(0)}`;
        
        const angleElement = document.getElementById('angle-value');
        angleElement.innerText = `${driftAngle}¬∞`;
        angleElement.style.color = driftAngle > 10 ? '#ff4444' : '#ffcc00';

        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.onload = init; 
</script>
</body>
</html>
